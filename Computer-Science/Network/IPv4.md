# IPv4

### IPv4 Header

```
IPv4 Header (min 20B)

0                   15 16                   31
+---------------------+----------------------+
| Version | IHL       | Type of Service      |
+---------------------+----------------------+
| Total Length                               |
+--------------------------------------------+
| Identification      | Flags | Frag Offset  |
+--------------------------------------------+
| TTL                 | Protocol             |
+---------------------+----------------------+
| Header Checksum                            |
+--------------------------------------------+
| Source Address                             |
+--------------------------------------------+
| Destination Address                        |
+--------------------------------------------+
| Options (if any) ... (padding)             |
+--------------------------------------------+
| Data (payload)                             |
+--------------------------------------------+

```

### IP 단편화(IP Fragmentation)

TCP는 송신 측에서 로컬 링크 MTU(Maximum Transmission Unit, 한 링크에서 프레임 payload로 실을 수 있는 최대 크기, 단위: byte)를<br>
기준으로 산출한 MSS(Maximum Segment Size)에 맞춰 세그먼트를 구성해 IP 계층에 인계한다.<br>
그러나 실제 전송 중 Path MTU가 더 작은 구간이 존재하면, 해당 IP datagram 은 다음 홉에서 그대로 전달될 수 없으므로,<br>
IPv4 라우터가 IP 단편화(IP fragmentation)를 수행하여 MTU에 맞는 여러 fragment로 분할 전송한다.

반면, IPv6는 원칙적으로 단편화를 수행하지 않는다.
라우터가 단편화를 수행할 경우 패킷을 분할·관리하는 추가 연산과 상태 처리가 필요해 처리 지연과 구현 복잡도가 증가하고,<br>
fragment 중 하나라도 유실되면 원본 패킷 전체를 재조립할 수 없어 전송 효율과 신뢰성이 급격히 떨어진다.<br>
따라서 IPv6는 라우터에 오버헤드로 부담을 주지 않고, 고속 포워딩(fast forwarding)에 집중할 수 있도록 설계되었다.<br>
IPv6에서 어떤 패킷이 MSS를 넘게 되면, 라우터는 해당 패킷을 드롭한 뒤 "ICMPv6 Packet Too Big" 메시지를 송신자에게 통지하여<br>
송신자가 Path MTU에 맞게 패킷 크기를 재조정하여 전송하도록 설계되어 있다.

\* 로컬 링크: 내 PC(호스트) ↔ 기본 게이트웨이(첫 라우터) 사이의 링크<br> \* $MSS = MTU − (IPv4 Header+TCP Header)$

### 서브넷 마스크(Subnet Mask) & 서브네팅(subnetting)

현재 인터넷의 기원은 미국 국방부 산하 고등연구계획국(DARPA)이 주도한 ARPANET 프로젝트로, 군·연구기관 간 통신을 목적으로 1969년에 구축된 초창기 패킷 교환 네트워크다.

시간이 지나면서 ARPANET 외에도 위성망, 무선망 등 다양한 네트워크가 생겨났고, 서로 다른 네트워크를 상호 연결(inter-network) 하기 위한 공통 규칙이 필요해졌다.<br>
이에 따라 서로 다른 네트워크들을 하나로 묶어 통신하게 하는 규칙인 Internet Protocol(IPv4)이 마련되었으며, 그 명세가 RFC 791(1981년)로 문서화되었다.

초기에는 인터넷의 규모가 작아, 당시 핵심 실무자였던 Jon Postel이 직접 IP 주소 관리를 주도했다.<br>
하지만 1990년대 들어 많은 기업과 국가들이 인터넷에 참여하기 시작했고, 전 세계 번호 자원을 한 곳에서 처리하기가 어려워지자,<br>
RIR(Regional Internet Registry)를 설립하여 지역 단위로 IP/ASN을 배분하고 관리하기 시작했다.

\- APNIC (아시아/태평양)<br>
\- RIPE NCC (유럽)<br>
\- ARIN (북미)<br>
\- LACNIC (중남미)<br>
\- AFRINIC (아프리카)

이후 인터넷이 더욱더 커지면서 기술적 문제를 넘어, 최상위 도메인 체계(DNS 루트)를 누가 운영·통제할지, IP/ASN 같은 전 세계 유일 자원을 어떤 원칙으로 배분·관리할지와 같은 거버넌스(권한·정책) 문제가 중요해졌다.<br>
이에 따라 인터넷의 이름·번호 자원 관리를 정부가 주도하던 방식에서 민간이 운영하는 방식으로 바꾸려는 흐름이 나타났고, 그 과정에서 1998년 ICANN이 설립되었다.

ICANN(Internet Corporation for Assigned Names and Numbers)은 인터넷 상에서 전 세계적으로 유일해야 하는 식별자 체계를 조정·관리하는 비영리 조직이며, 대표적으로 다음을 다룬다.

\- DNS 루트(최상위 도메인 체계: .com, .kr 등)<br>
\- IP 주소(산하 기관인 IANA이 담당)<br>
\- ASN(Autonomous System Number, 인터넷 망에서 회사/기관을 식별하는 번호)<br>

ICANN 산하 IANA는 각 RIR이 맡아 관리할 IPv4 주소 영역을 앞 8비트가 특정 값으로 고정된 프리픽스 블록(prefix block)형태로 할당한다.<br>
예를 들어, 124.0.0.0/8은 앞 8비트가 124로 고정된 프리픽스 블록이며, 이는 앞 8비트 값이 124로 시작하는 모든 IPv4 주소를 내포한다.<br>
이후 RIR은 이 블록을 기반으로 124.0.0.0/16, 124.1.0.0/16, 124.50.10.0/24 ... 처럼 프리픽스 길이를 더 길게 고정함으로써, 더 세분화된 주소 범위를 관할 내 기관이나 ISP에 재할당할 수 있다.<br>
이처럼 하나의 프리픽스 블록은 특정 네트워크의 영역을 정의할 수 있으며, 이를 더 작은 여러 개의 네트워크(서브넷)로 쪼개는 것을 서브네팅(subnetting)이라 한다.<br>
또한 IP 주소에서 프리픽스로 고정된 부분을 네트워크 ID(Network ID), 나머지 부분을 호스트 ID(Host ID)라고 한다.

| 클래스 | 주소 영역 구분 (네트워크 + 호스트)      | 서브넷 마스크 | 식별용 상위 비트 | 주소 범위                   |
| :----: | :-------------------------------------- | :------------ | :--------------: | :-------------------------- |
|   A    | **네트워크** (8비트) + 호스트 (24비트)  | 255.0.0.0     |   `0xxx xxxx`    | 0.0.0.0 ~ 127.255.255.255   |
|   B    | **네트워크** (16비트) + 호스트 (16비트) | 255.255.0.0   |   `10xx xxxx`    | 128.0.0.0 ~ 191.255.255.255 |
|   C    | **네트워크** (24비트) + 호스트 (8비트)  | 255.255.255.0 |   `110x xxxx`    | 192.0.0.0 ~ 223.255.255.255 |
|   D    | (멀티캐스트 용)                         | -             |   `1110 xxxx`    | 224.0.0.0 ~ 239.255.255.255 |
|   E    | (실험용, 장래대비용)                    | -             |   `1111 xxxx`    | 240.0.0.0 ~ 255.255.255.255 |

서브넷 마스크(subnet mask)는 목적지 IP가 같은 네트워크 영역에 속하는지 여부를 판별하기 위한 도구다.<br>
구체적으로 장비는 목적지 IP 주소와 서브넷 마스크에 대해 비트 AND 연산을 수행하여 네트워크 ID를 계산한다.

예를 들어, 내 IP가 192.168.1.10이고 목적지 IP가 192.168.1.50일 때, 서브넷 마스크가 255.255.255.0이라고 하자.<br>
이때 각 IP에 대해 서브넷 마스크와 AND 연산을 수행하면

내 네트워크 주소: 192.168.1.10 & 255.255.255.0 = 192.168.1.0<br>
목적지 네트워크 주소: 192.168.1.50 & 255.255.255.0 = 192.168.1.0<br>

두 네트워크 주소가 동일하므로, 목적지는 같은 네트워크에 속한다고 판단하며 게이트웨이를 거치지 않고 LAN 내부에서 전송 가능하다.

과거에는 IPv4 주소 범위를 위와 같이 크게 클래스 A ~ E로 구분했기 때문에<br>
서브넷 마스크도 `255.0.0.0`, `255.255.0.0`, `255.255.255.0` 3가지 형태면 충분하였다.<br>
그러나 범위의 간격이 너무 커서, 실제 필요보다 훨씬 더 많은 주소를 할당받는 기관이 생기는 등 주소 공간이 비효율적으로 쓰였다.<br>
이러한 문제를 해결하기 위해, 오늘날에는 CIDR(Classless Inter-Domain Routing) 표기를 사용하여 주소 범위를 세 가지(`/8`, `/16`, `/24`)로만 고정하지 않고,<br>
필요에 따라 `/20`이나 `/27`처럼 다양한 프리픽스 길이를 허용하고 이에 알맞은 서브넷 마스크(`/20` → `255.255.240.0`, `/27` → `255.255.255.224`)를 사용함으로써,<br>
여러 규모의 네트워크를 정의할 수 있도록 한다.<br>
