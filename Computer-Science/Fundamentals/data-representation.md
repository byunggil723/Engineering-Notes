# 데이터의 표현

### 비트(Bit)와 바이트(Byte)

비트(bit): 컴퓨터 데이터의 최소 단위. 0 또는 1.

바이트(byte): 8비트(8개의 0과 1)로 구성된 단위.

| 단위   | 구성       | 의미               |
| ------ | ---------- | ------------------ |
| 1 bit  | 0 or 1     | 전류의 on/off      |
| 1 byte | 8 bits     | 영문 기준 문자 1개 |
| 1 KB   | 1024 bytes | 약 천 바이트       |
| 1 MB   | 1024 KB    | 약 백만 바이트     |

### 유니코드

전 세계의 모든 문자를 하나의 체계로 표현하기 위해 만든 문자 집합 체계.
모든 글자에 고유한 번호(코드 포인트)가 부여되어 있다.

ASCII로는 전 세계 문자를 표현하기에 부족해서, ASCII를 포함하면서 확장한 문자 인코딩 체계다.

따라서 영어 알파벳은 ASCII와 동일하게 유니코드 코드포인트 값이 0 \~ 127 범위이기 때문에
1바이트(8비트) 만으로 표현할 수 있다.
반면 한글은 U+AC00 ('가', 1010 1100 0000 0000₂ ≈ 44032₁₀) 처럼 큰 번호를 가지므로
1바이트로는 부족하고, UTF 인코딩 규칙에 따라 2~3바이트 이상이 필요하다.

\* 인코딩(encoding): 부호화, 암호화

> UTF(Unicode Transformation Format)

UTF는 유니코드의 코드포인트를 실제 0과 1의 바이트열로 바꾸는 **인코딩 규칙**이다.

| 인코딩 | 문자 1개당 바이트 수 | 특징                       |
| ------ | -------------------- | -------------------------- |
| UTF-8  | 1~4바이트 (가변)     | 영어 1바이트, 한글 3바이트 |
| UTF-16 | 2 또는 4바이트       | 기본적으로 2바이트         |
| UTF-32 | 4바이트 고정         | 단순하지만 비효율적        |

UTF-8은 문자 코드(유니코드 코드포인트)를 1~4바이트로 나눠 저장한다.
어떤 범위의 문자가 몇 바이트를 쓰는지는 다음과 같다:

| 코드포인트 범위    | 바이트 수 | 비트 패턴                             |
| ------------------ | --------- | ------------------------------------- |
| U+0000 ~ U+007F    | 1 byte    | `0xxxxxxx`                            |
| U+0080 ~ U+07FF    | 2 bytes   | `110xxxxx 10xxxxxx`                   |
| U+0800 ~ U+FFFF    | 3 bytes   | `1110xxxx 10xxxxxx 10xxxxxx`          |
| U+10000 ~ U+10FFFF | 4 bytes   | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` |

문자 '가'를 예시로 보자.
'가'의 유니코드 코드포인트는 U+AC00 = 44032₁₀ = 1010 1100 0000 0000₂ 이다.
이를 UTF-8 규칙에 따라 인코딩을 하기 위해선 U+07FF < U+AC00 < U+10000 이므로 총 3바이트를 사용해야 하고, 1010 1100 0000 0000₂을 비트 패턴에 따라 3바이트 공간에 나누어 담으면 최종적으로
11101010 10110000 10000000₂ = EA B0 80₁₆ 형태로 저장된다.
반면, UTF-16 또는 UTF-32로 인코딩을 하는 경우에는 UTF-8처럼 별도의 템플릿을 사용하지 않고 16비트(또는 32비트) 고정 폭 구조에 그대로 저장하므로 1010 1100 0000 0000₂ 가 10101100 00000000₂ 형태로 저장된다.

따라서, VSCode와 같은 IDE에서 프로젝트 파일을 UTF-8로 저장한 뒤,
HTML 파일에서 <meta charset="UTF-16"\>으로 설정해 두면,
브라우저가 해당 문서를 잘못된 인코딩 규칙으로 해석하게 되어 문자 깨짐 현상이 발생한다.

1990년대 이전에는 유니코드가 표준화되지 않았었다.
그래서 나라별로 독자적인 문자 코드 체계를 만들어 사용하였다.

일본 → Shift-JIS
중국 → GB2312, GBK
한국 → EUC-KR (KS C 5601 → KS X 1001)

2000년대 이후, 웹과 운영체제가 국제화되면서
모든 나라가 각자 따로 쓰던 체계를 버리고 유니코드로 통합하기 시작했다.
그래서 현재
웹 표준: UTF-8
Windows, macOS, Linux: 유니코드 기반
EUC-KR은 레거시(legacy) 인코딩
으로 분류된다.

### Base64

Base64는 컴퓨터 안에 저장된 이진(binary) 데이터를 전송/수신할 때, 통신 프로토콜에서 사용하는 제어 문자나 구분자와 충돌하지 않도록, 미리 정해진 64개의 문자만을 사용하여 문자열 데이터로 변환하는 인코딩 규칙이다.

예를 들어, 이미지 파일(.png)을 전송할 때 내부에 저장된 `01001100 11100010 ...` 형태의 바이너리 데이터를 Base64를 거쳐 `iVBORw0KGgoAAAANSUhEUgAA...` 로 변환하여 전송하게 된다.

```bash
{
  "image": "iVBORw0KGgoAAAANSUhEUgAA..."
}
```

이미지에 해당하는 데이터 영역은 정해진 64개의 문자(A~Z, a~z, 0~9, +, /) 내에서만 표현되기 때문에 네트워크 전송, JSON 파싱, HTML 임베딩 등에서 모두 안전하게 전달이 된다.

Base64의 인코딩 테이블은 다음과 같다.

| 값(10진수) | 문자 | 값(10진수) | 문자 | 값(10진수) | 문자 | 값(10진수) | 문자 |
| ---------- | ---- | ---------- | ---- | ---------- | ---- | ---------- | ---- |
| 0          | A    | 16         | Q    | 32         | g    | 48         | w    |
| 1          | B    | 17         | R    | 33         | h    | 49         | x    |
| 2          | C    | 18         | S    | 34         | i    | 50         | y    |
| 3          | D    | 19         | T    | 35         | j    | 51         | z    |
| 4          | E    | 20         | U    | 36         | k    | 52         | 0    |
| 5          | F    | 21         | V    | 37         | l    | 53         | 1    |
| 6          | G    | 22         | W    | 38         | m    | 54         | 2    |
| 7          | H    | 23         | X    | 39         | n    | 55         | 3    |
| 8          | I    | 24         | Y    | 40         | o    | 56         | 4    |
| 9          | J    | 25         | Z    | 41         | p    | 57         | 5    |
| 10         | K    | 26         | a    | 42         | q    | 58         | 6    |
| 11         | L    | 27         | b    | 43         | r    | 59         | 7    |
| 12         | M    | 28         | c    | 44         | s    | 60         | 8    |
| 13         | N    | 29         | d    | 45         | t    | 61         | 9    |
| 14         | O    | 30         | e    | 46         | u    | 62         | +    |
| 15         | P    | 31         | f    | 47         | v    | 63         | /    |

변환 규칙은 다음과 같다.

1. 데이터를 6비트 단위로 쪼갠다.
2. 각 6비트 값을 10진수로 표현한다.
3. 위 테이블에서 각 10진수에 해당하는 문자를 찾아 바꾼다.
4. 데이터가 3의 배수가 아니면 =로 패딩을 붙인다.

예를 들어, `Man` 이라는 단어를 전송하는 경우

```bash
'Man' → 01001101 01100001 01101110
→ 010011 | 010110 | 000101 | 101110
→ 19, 22, 5, 46
→ T W F u
```

의 과정을 거쳐 `TWFu` 의 형태로 전송된다.
