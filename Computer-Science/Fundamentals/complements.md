# 보수(補數, Complement)

보수(補數, Complement)는 말그대로 '보충하는 수'이다.

예를 들어, 10진법에서 4의 10의 보수는 10 - 4 = 6이고, 46의 9의 보수는 99 - 46 = 54이다.<br>
n진법에서 n-1의 보수를 활용하게 되면 자리 차용(borrow)을 피하기 위한 도구로 사용된다.

이 성질은 컴퓨터 구조에서 결정적인 역할을 한다. CPU 내부 연산은 이진수 기반의 고정된 비트 수에서 수행되는데,<br>
뺄셈 연산을 별도로 구현하려면 경우에 따른 연산 방식의 분기가 필요해 회로가 복잡해진다.

예를 들어 최상위 비트를 단순히 부호 비트로 사용한다고 가정하자.<br>
이때 -6 (=1000 0110) + 9 (=0000 1001) 계산은 어떻게 할 것인가?<br>
9 - 6의 경우, 이진수의 뺄셈 연산을 그대로 진행하면 되지만,<br>
6 - 9와 같은 경우는 9 - 6으로 바꾼 후에 다시 -부호를 붙여 주어야 한다.

반면, 덧셈과 보수만으로 모든 연산을 통일하면 하나의 덧셈 회로로 모든 경우를 처리할 수 있으며, 이는 하드웨어 구현 측면에서 훨씬 효율적이다.

활용방법을 알아 보기 위해, 우선 unsinged int에 대해서 부터 먼저 생각해 보자.<br>
4비트가 최대라 할 때,<br>
0000 = 0<br>
0001 = 1<br>
0010 = 2<br>

...<br>

1111 = 15<br>
가 될 것이다.<br>

여기서 8(=1000) + 9(1001)은 17(0001 0001)인데, 최대 비트가 4로 한정되어 있으므로 맨 앞 비트 1은 버린다.<br>
즉, 1이 된다.<br>

이제 signed int에 대해 생각해 보자.<br>
맨 앞의 비트를 sign으로 사용하여 다음과 같이 정의한다면,<br>
0000 = 0<br>
0001 = 1<br>
0010 = 2<br>

...<br>

0111 = 7<br>
1000 = -8 (= 8) -> 8의 1의 보수(0111) + 1<br>
1001 = -7 (= 9) -> 7의 1의 보수(1000) + 1<br>
1010 = -6 (= 10) -> 6의 1의 보수(1001) + 1<br>

...<br>

1111 = -1 (= 15) -> 1의 1의 보수(1110) + 1<br>
이다.<br>

여기서 -8 + -7<br>
= (8 ≡ -8 (mod 16)) + (9 ≡ -7 (mod 16))<br>
= 8 + 9<br>
= 1000 + 1001<br>
= (0001 0001)인데, 최대 비트가 4로 한정되어 있으므로 앞의 4비트는 버린다.<br>
역시나 연산 결과는 1 (= 0001)이 된다.<br>

이처럼 상위 비트의 버림(truncation)이 허용되고, 부호가 구분됨에도 불구하고 덧셈 연산 하나만으로 결과의 부호가 자동으로 결정되는 이유는,<br>
컴퓨터의 정수 연산이 대수적으로 $Z_{16}$ 구조 위에서 정의되어 있기 때문이다.<br>
이진수 관점에서 보면, 최상위 이전 비트들은 일반적인 이진 덧셈 규칙에 따라 자연스럽게 캐리를 전달하며 계산되고,<br>
최상위 비트(= 0001 0000, 16)를 버리는 것은 마치 mod 16 연산처럼 연산 결과를 다시 해당 구조 내부로 환원하는 과정에 해당한다.<br>
따라서, {-8, -7, -6, ... , 7}과 같은 signed 대표계를 사용하든, {0, 1, 2, ... , 15}와 같은 unsigned 대표계를 사용하든, 내부 연산 결과는 항상 동일한 동치류로 귀결된다.

다만 이러한 해석이 가능하려면, 음수와 이진수 표현이 위와 같이 $Z_{16}$의 구조에 정확히 대응되도록 정의되어야 한다.
