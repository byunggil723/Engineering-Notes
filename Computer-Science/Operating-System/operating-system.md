# OS(Operating System)란?

**운영체제(Operating System)**&#8203;는 하드웨어 위에서 동작하며,
사용자 프로그램이 안전하게 CPU, 메모리, 저장장치, 네트워크 등을 사용할 수 있게 해주는 **중간 관리자**&#8203;다.

### OS 구조

OS의 구조는 크게 **사용자 공간(User Space)**&#8203;와 **커널 공간(Kernel Space)**&#8203;로 나눌 수 있다.
사용자 공간에서는 일반 응용 프로그램이 실행되고, 커널 공간에서는 시스템 콜을 통해 요청된 작업을 수행하며 CPU, 메모리, 저장장치 등 하드웨어 자원을 직접 관리하는 커널 코드가 동작한다.

사용자 공간과 커널 공간은 **시스템 콜(System Call)**&#8203;을 통해 연결된다.
사용자 공간에서 실행되는 프로그램은 하드웨어의 자원을 사용하기 위해, 시스템 콜이 제공하는 인터페이스를 통해 커널에 요청을 전달하고 그 결과를 이용한다.

**쉘(Shell)**&#8203;은 사용자가 운영체제의 커널과 직접 상호작용하기 위해 거치는 인터페이스이다.
쉘은 크게 **GUI(Graphical User Interface)**&#8203;와 **CLI(Command-Line Interface)**&#8203;로 나눌 수 있다.
macOS에서는 GUI 쉘로 Finder, CLI 쉘로 bash, zsh 등이 사용된다.
zsh나 bash와 같은 CLI 쉘 또한 사용자 공간 위에서 실행되는 하나의 응용 프로그램으로서 사용자가 터미널을 통해 입력한 명령어를 해석(interpret)하여, 필요한 경우 시스템 콜(System Call)을 통해 커널에 작업을 요청한다.

사용자 프로그램은 커널의 기능(예: 파일 열기, 메모리 할당, 프로세스 생성 등)을 직접 수행할 수 없다.
따라서 시스템 콜을 호출하면 CPU가 사용자 모드 → 커널 모드로 전환되며
커널이 대신 그 요청을 안전하게 처리한다.

예를 들어,

```C
#include <stdio.h>
#include <fcntl.h>

int main() {
    int fd = open("file.txt", O_RDONLY);
    printf("fd = %d\n", fd);
}
```

위와 같은 C 코드를 실행할 때 일어나는 내부적인 과정을 살펴 보자. (리눅스 기준)

1. 사용자가 main.c라는 텍스트 파일에 코드를 작성하고 저장한다. 이 파일은 SSD (보조기억장치)에 저장되어 전원이 꺼져도 내용이 유지된다.

2. 컴파일러를 통해 C 코드를 기계어로 변환한다.

   ```bash
   gcc main.c -o a.out
   ```

   컴파일러(GCC)가 하는 일은 다음의 네 단계로 나뉜다.

   (1) 전처리 (Preprocessing): #include에 정의된 실제 헤더 코드를 복사
   → 수천 줄의 코드가 담긴 main.i 파일 생성

   (2) 컴파일 (Compilation): 전처리된 C 코드를 어셈블리어로 변환
   → main.s 파일 생성

   (3) 어셈블 (Assemble): 어셈블리어를 바이너리 형탱의 기계어로 변환
   → main.o 파일 생성

   (4) 링크 (Link): 여러 오브젝트 파일(.o) + glibc 라이브러리 연결
   → 최종적으로 a.out 실행 파일 생성 + SSD에 저장

   \* glibc (GNU C Library): 운영체제에 미리 설치된 리눅스용 C 표준 라이브러리 구현체
   `printf`, `malloc`, `open`, `read` 같은 C 표준 함수 + 시스템 콜 인터페이스
   보통 `/lib/x86_64-linux-gnu/libc.so.6` 같은 형태로 존재
   gcc나 clang 같은 컴파일러는 glibc 대신 다른 C 표준 라이브러리(Darwin libc - Mac OS)도 사용할 수도 있음

   리눅스에서 생성되는 a.out 실행 파일은 ELF(Executable and Linkable Format) 포맷을 따르며, 그 내부 구조는 다음과 같다.

   ```bash
   +-----------------------------+
   | ELF Header                  | ← 파일 전체의 개요 정보
   +-----------------------------+
   | Program Header Table        | ← OS가 메모리에 올릴 때 참고
   +-----------------------------+
   | .text                       | ← 기계어 명령어
   | .rodata                     | ← 상수 데이터(ex: 문자열 리터럴, 전역 선언된 cons
   | .data                       | ← 초기값 있는 전역 변수
   | .bss                        | ← 초기값 없는 전역 변수
   | .symtab                     | ← 심볼(변수, 함수명) 정보
   | .got                        | ← 외부 함수/변수 주소 테이블 (Global Offset Table)
   | .rel.plt                    | ← 링크 정보
   | ...                         |
   +-----------------------------+
   | Section Header Table        | ← 각 섹션의 이름, 크기, 위치
   +-----------------------------+
   ```

   링크 방식에는 `정적 링크(static linking)` 와 `동적 링크(dynamic linking)` 가 있다.
   **정적 링크 방식**&#8203;은 실행 파일(a.out)을 생성할 때, 코드에서 사용하는 glibc 함수의 기계어 코드가 실행 파일 내부에 직접 포함하는 방식이다.
   하지만 C 표준 라이브러리는 규모가 크고 내부 의존성이 복잡하기 때문에,
   하나의 함수만 사용하더라도 그에 연관된 많은 코드가 함께 포함되어 실행 파일의 크기가 커지는 문제가 발생한다.
   이러한 비효율을 줄이기 위해, 현대 시스템에서는 대부분 동적 링크 방식을 사용한다.
   **동적 링크 방식**&#8203;은 실행 파일을 실행할 때, 동적 로더(ld-linux.so)가 glibc 전체를 가상 메모리 주소 공간에 매핑하고, 그중 실행 파일이 호출하는 함수들(printf, malloc, read 등)이 담긴 코드 페이지만 실제 RAM(물리 메모리)에 로드하여 사용하는 방식이다.
   `.rel.plt` 섹션은 이 과정에서 로더가 어떤 외부 함수(심볼)를 glibc에서 찾아야 하는지,
   그리고 그 함수의 주소를 .got(Global Offset Table)의 어느 위치에 채워 넣어야 하는지를 명시한 재배치 정보(relocation information) 를 담고 있다.

   ```bash
   .rel.plt:
     [0] printf → GOT[0x601018]
     [1] malloc → GOT[0x601020]
   ```

   ```bash
   .got:
     0x601018 → 0x7f9c5234a2c0  # 로더가 채운 RAM에 있는 glibc printf() 코드 시작 주소
     0x601020 → 0x7f9c5231c180  # 로더가 채운 RAM에 있는 glibc malloc() 코드 시작 주소
   ```

   동적 링크는 링크 시점에 따라서 다시 **즉시 바인딩(Eager binding)**&#8203;과 **지연 바인딩(Lazy binding)**&#8203;으로 나뉜다.
   즉시 바인딩 방식은 프로그램 시작 시, 로더가 .rel.plt를 전부 해석해서 .got 엔트리 모두 채운다.
   지연 바인딩 방식은 함수가 처음 호출될 때마다 그 함수의 주소를 찾아 .got에 기록한다.
   이미 한 번 기록된 함수를 사용하는 경우, 기존 주소를 그대로 사용한다.

3. 사용자가 터미널에서 다음의 명령어를 입력하여 컴파일된 파일을 실행한다.

   ```bash
   ./a.out
   ```

   쉘은 이 명령어를 해석하여 기계어 코드로 변환하고, 쉘 프로세스가 실행되는 동안 CPU는 RAM의 쉘 메모리 영역에 적재된 쉘 코드(.text)의 해당 명령어를 처리하게 된다.

   ```bash
   syscall: execve("a.out", argv, envp)
   ```

   제어 장치(CU)가 이 시스템 콜 명령어를 해석하는 순간 CPU는 사용자 모드에서 커널 모드로 전환되며,
   프로그램 카운터(PC)는 RAM에 상주 중인 커널 코드(.text)의 진입점 주소로 변경된다.
   이후 CPU는 커널 메모리 영역의 execve 관련 명령어들을 프로그램 카운터(PC) → 메모리 주소 레지스터(MAR) → 메모리 버퍼 레지스터(MBR) → 명령어 레지스터(IR) → 제어 장치(CU)의 순서로 처리하며, SSD에 저장된 a.out 파일을 RAM에 적재하여 새로운 프로세스를 구성하게 된다.
   시스템 콜 처리가 끝나면, 커널은 sysret 명령어를 통해 CPU 제어를 사용자 모드로 복귀시키고,
   CPU는 다시 사용자 메모리 영역의 다음 명령어를 실행하게 된다.

   RAM에는 다음의 영역이 새로 배치된다.

   ```bash
   ┌─────────────────────────┐
   │ Stack                   │ ← 함수 호출, 지역 변수 (함수 본문은 .text 섹션에 존재하며, 스택에는 그 위치(주소)만 저장
   │                         │   단, C 표준 라이브러리 내부 함수는 .text에 존재 X, RAM의 다른 영역에 해당 본문이 존재)
   ├─────────────────────────┤
   │ Heap                    │ ← malloc/new 등 동적 할당
   │ (프로그램 실행 중 확장)    │
   ├─────────────────────────┤
   │ BSS 영역 (.bss)          │ ← 초기값 없는 전역 변수
   ├─────────────────────────┤
   │ Data 영역 (.data)        │ ← 초기값 있는 전역 변수
   ├─────────────────────────┤
   │ Read-Only Data (.rodata)│ ← 상수 데이터(ex: 문자열 리터럴, 전역 선언된 const 정수)
   ├─────────────────────────┤
   │ Code 영역 (.text)        │ ← CPU가 실행할 명령어
   ├─────────────────────────┤
   │ Kernel / 공유 라이브러리   │ ← 모든 프로세스가 공유하는 단일 커널 코드 + glibc (내부에 시스템 콜 인터페이스가 정의되어 있음)
   └─────────────────────────┘

   ```

   \* 상수, 리터럴
   상수: 값이 변하지 않는 데이터
   리터럴(literal): 소스 코드에 그대로 적힌 값으로, 컴파일러가 별도 계산없이 직접 해석하는 데이터

   ```C
   const int a = 10;       // 상수 (리터럴로 초기화)
   const int b = a + 5;    // 상수 (리터럴로 초기화된 건 아님)
   int c = 10;             // 리터럴로 초기화됐지만 변수 (변경 가능)
   int d = b + 3;          // 리터럴 아님, 실행 중 계산
   ```

4. 이제 CPU는 RAM의 코드 영역(.text)에서 실행할 명령어가 위치한 주소를
   프로그램 카운터(PC, Program Counter) 레지스터에 넣고 프로그램 실행을 시작한다.

5. 프로그램 카운터 레지스터에 저장된 주소는 메모리 주소 레지스터(MAR, Memory Address Register)로 전달된다.
   메모리 주소 레지스터는 해당 주소에 존재하는 명령어를 가져와 메모리 버퍼 레지스터(MBR, Memory Buffer Register)에 저장한다.

   ```bash
   401156: e8 d5 fe ff ff          call   401030 <printf@plt>   # glibc의 printf() 호출
   ```

6. 메모리 버퍼 레지스터에 저장된 명령어는 다시 명령어 레지스터(IR, Instruction Register)로 이동하고, 프로그램 카운터에 저장된 주소값이 그 다음 주소값으로 바뀐다.

7. 명령어 레지스터에 저장된 명령어는 제어 장치(CU, Control Unit)로 이동하여 해석된다.
   printf()는 구조체는 내부에서 write() 시스템 콜을 호출한다.

8. 제어 장치가 write() 시스템 콜 명령어를 해석할 때, CPU는 사용자 모드에서 커널 모드로 전환되어 해당 명령어를 실행하게 된다.

9. write 명령어의 실행이 끝나면, CPU는 다시 사용자 모드로 복귀하여 다음 명령어를 처리합니다.

-------- 추후 수정 필요! --------

디스크 내부에는 파일과 폴더를 관리하기 위한 일정한 규칙이 구성되어 있다. 이를 파일 시스템이라 하며, 그 안에는 PC에 설치된 운영체제 구성 요소 또한 저장되어 있다.<br>
컴퓨터가 실행되고 부트로더가 커널을 메모리에 올려 실행하면, 커널은 디스크의 파일 시스템 시작점을 `/`로 설정하여 하위 폴더나 파일에 접근할 수 있게 한다.<br>
이후 GUI는 해당 구조를 사용자에게 시각적으로 제공하며 운영체제 파일들도 그 구조 속에서 드러나게 된다.

-------- 추후 수정 필요! --------

서버란 네트워크를 통해 다수의 사용자에게 서비스를 제공하는 시스템을 말한다.<br>
반대로 클라이언트란 네트워크 상에서 서버에 데이터를 요청하고, 서버로부터 정보를 받거나 서비스를 제공받는 장치(데스크톱, 스마트폰)나 응용 프로그램(웹 브라우저)을 말한다.

일반적으로 저장 장치, 입출력 장치, 네트워크 장비 등을 포함한 하드웨어의 집합을 컴퓨터 또는 물리 서버라고 하며, 이 물리 장비를 실제로 가동시키고 CPU, 메모리, 디스크, NIC와 같은 자원을 관리하는 소프트웨어가 운영체제이다.<br>
운영체제는 사용 목적에 따라 개인 사용을 중심으로 한 클라이언트용과 네트워크를 통한 서비스 제공을 중심으로 하는 서버용으로 구분되는데,<br>
이는 제공되는 기능 종류의 차이라기보다, 용도에 따른 자원 관리 방식과 성능 최적화 대상의 우선순위 차이에서 비롯된다.<br>
클라이언트용 운영체제도 서버 실행 용도로 사용할 수 있으나, 서버 전용 운영체제가 동시 접속 처리, 안정성, 보안, 중앙 관리 측면에서 보다 더 나은 설계가 되어 있다.<br>
서버 용도로 운영체제를 사용하는 경우, 하나의 운영체제 안에 웹 서버, DB 서버와 같은 여러 서버 프로그램을 함께 실행할 수도 있고,<br>
가상화(하나의 물리 서버 위에 여러 운영체제를 배치)나 컨테이너(하나의 운영체제 여러 프로세스 환경을 배치)를 통해 서버 실행 환경을 분리할 수도 있다.<br>
이처럼 서버는 물리 장비나 운영체제 자체를 의미하는 것이 아니라, 해당 환경 위에서 네트워크를 통해 특정 기능을 제공하는 서비스를 가리키며, 여러 서버 프로그램이 유기적으로 결합되어 하나의 통합된 서비스를 구성한다.

컨테이너는 프로세스 하나를 독립된 서버처럼 보이게 하기 위해 그 프로세스가 인식하는 실행 환경을 분리하는 기술로,<br>
파일 시스템과 네트워크를 분리해 실행 환경과 네트워크 주소를 분리(내부적으로 각 컨테이너마다 사설 IP를 할당)하고,<br>
프로세스 공간을 분리해 서로의 프로세스가 보이지 않도록 하며,<br>
사용자 공간을 분리해 커널 자원에 대한 제어 권한이 컨테이너 내부로 제한되도록 하고,<br>
cgroup을 통해 CPU, 메모리와 같은 리소스 사용량을 제한한다.<br>

Kubernetes는 이러한 컨테이너들을 대규모로 운영하기 위한 시스템으로, 컨테이너의 실행 위치를 자동으로 배치하고 장애 발생 시 재시작하며,<br>
트래픽 변화에 따라 컨테이너 수를 자동으로 조절함으로써 개별 컨테이너가 아닌 서비스 단위의 안정적인 운영 상태를 유지한다.
