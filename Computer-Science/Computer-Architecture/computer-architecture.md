# 컴퓨터 구조

컴퓨터의 실행 과정을 통해 컴퓨터의 구조를 알아 보자.

### 시스템 펌웨어 (System Firmware)

컴퓨터의 전원이 켜지면 가장 먼저 실행되는 프로그램이다.
대표적인 예로 BIOS와 UEFI가 있다.
전원이 들어 오면, CPU는 항상 고정된 플래시 메모리(ROM)의 주소를 읽어 시스템 펌웨어를 실행한다.
시스템 펌웨어는 CPU, 메모리, 저장 장치, 그래픽, 입출력 장치 등 주요 하드웨어를 초기화하여 실행 가능한 상태로 설정하고, 저장 장치(SSD, HDD, USB 등)에서 부트 로더(Boot Loader)를 찾아 RAM으로 로드하여 실행한다.

### 부트 로더 (Boot Loader)

부트로더는 커널 실행 파일을 저장 장치로부터 읽어, 이를 RAM의 특정 주소(커널이 실행될 물리 메모리 공간)에 적재한다.
그런 다음 커널의 헤더(header) 정보를 분석하여 실제 실행 시작 위치(entry point) 를 확인하고, CPU의 프로그램 카운터(Program Counter, PC) 레지스터에 해당 주소를 저장한다.
이후 CPU는 PC가 가리키는 커널의 첫 명령어를 실행하기 시작하며, 운영체제의 제어권이 부트로더에서 커널로 완전히 넘어간다.

### CPU (Central Processing Unit)

CPU는 프로그램의 명령어를 해석(Decode)하고 실행(Execute)하는 컴퓨터 시스템의 중앙 연산 장치이다.

CPU는 ISA를 기반으로 설계된다.
ISA(Instruction Set Architecture)는 어셈블리어 명령어와 그 명령어가 실제로 CPU 내부에서 실행될 때의 이진 비트 패턴(기계어)을 정확히 1:1로 대응시키는 명세서이다.

```assembly
 add x5, x6, x7
 → 0000000 00111 00110 000 00101 0110011
 // RISC-V, 레지스터 x6의 값과 x7의 값을 더해서, 그 결과를 x5에 저장
```

주요 ISA의 종류는 다음과 같다.

| ISA                             | 주요 특징                                                                                                                                                                                                                          | 대표 CPU                                                            |
| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **x86 / x86-64 (CISC 계열)**    | **복잡한 명령어 구조(Complex Instruction Set Computer)**. 1978년 **Intel 8086**부터 시작했으며, 명령어 길이가 **가변적(1~15바이트)**이고 하나의 명령어가 여러 연산을 수행 가능. 하위호환성을 매우 강하게 유지하여 현재까지 이어짐. | **Intel Core 시리즈**, **AMD Ryzen**, **Xeon**                      |
| **ARM (RISC 계열)**             | **간결한 명령어 구조(Reduced Instruction Set Computer)**. 명령어 길이가 32비트로 **고정적(Thumb 모드에서는 16비트)**이며 단순하고 전력 효율이 높음. 임베디드부터 스마트폰, 서버까지 폭넓게 사용.                                   | **Apple M1/M2/M3**, **Snapdragon**, **Exynos**, **Cortex-A 시리즈** |
| **RISC-V (RISC 계열)**          | **완전한 오픈소스 ISA**. **기본 명령어 길이 32비트로 고정**, 단 **Compressed ISA 확장 시 16비트 명령어**도 지원. 누구나 무료로 설계·확장 가능하며 교육·연구·AI 분야에서 빠르게 확산 중.                                            | **SiFive U740**, **Alibaba Xuantie C910**, **StarFive JH7110**      |
| **MIPS (RISC 계열)**            | **단순하고 교과서적인 설계**. 명령어 길이가 **고정(32비트)**이며, 교육용·임베디드용으로 널리 사용되었으나 ARM 등장 이후 쇠퇴.                                                                                                      | **MIPS R4000**, **Broadcom BCM74xx**                                |
| **POWER / PowerPC (RISC 계열)** | **IBM이 개발한 RISC 계열 ISA**. 명령어 길이가 **고정(32비트)**이며, 대형 서버와 슈퍼컴퓨터용으로 사용. 과거 Apple의 PowerPC 맥에도 쓰임.                                                                                           | **IBM POWER9**, **Power10**                                         |
| **SPARC (RISC 계열)**           | **Sun Microsystems 설계의 RISC ISA**. 명령어 길이가 **고정(32비트)**이고, 대형 서버용으로 사용되었으나 현재는 역사적 의미가 큼.                                                                                                    | **UltraSPARC**, **LEON (ESA 위성용)**                               |

32비트 운영체제와 64비트 운영체제는 CPU가 한 번에 처리할 수 있는 데이터 단위에 따라 구분된다. 이는 CPU의 **레지스터와 주소 버스의 폭(비트 수)**에 의해 결정된다.
64비트 운영체제는 한 번에 처리할 수 있는 데이터의 크기가 더 크기 때문에, 일반적으로 32비트 운영체제보다 더 높은 성능을 발휘한다. 현재 대부분의 컴퓨터는 64비트 운영체제를 사용한다.
64비트 운영체제는 32비트 ISA를 확장한 형태로,
64비트 운영체제에서 동작하는 프로그램이 32비트 운영체제에서는 호환되지 않을 수 있다.

CPU는 RAM보다 몇 백배 빠르다. 이를 위해 L1, L2, L3 캐시를 둔다.

CPU는 특정 프로그램을 실행하기 위해 RAM에 적재된 기계어 코드(.text) 명령어를 처리한다.

프로그램 카운터(PC)에는 현재 실행할 명령어가 위치한 사용자 메모리 영역(.text)의 주소가 저장된다. 해당 주소는 메모리 주소 레지스터(MAR)로 전달되고, 메모리로부터 읽어 온 명령어는 메모리 버퍼 레지스터(MBR)에 적재된다.
이후 명령어는 명령어 레지스터(IR)에 로드되며, 제어 장치(CU)는 이를 해독하여 실행을 제어한다.
사용자 메모리 영역의 코드 실행 중 새로운 프로그램 실행을 요청하는 시스템 콜(예: execve)을 만나면, CPU는 커널 모드로 전환되어 커널 메모리 접근 가능 권한을 획득한 상태가 되어 커널 메모리에 있는 시스템 콜 처리 코드를 가져와 실행한다.
실행 파일 a.out을 보조기억장치(SSD)에서 RAM으로 적재하고, 새로운 프로세스를 구성한다.
시스템 콜 처리가 완료되면, 커널은 sysret 명령어를 통해 CPU 제어를 사용자 모드로 복귀시키고,
CPU는 기존 프로그램의 명령어 혹은 새로 적재된 프로그램의 진입점(entry point) 명령어 실행을 다시 시작한다.

### RAM

```assembly
 mov rax, 10          ; 64비트 정수 저장 (long long)
 → 01001000 11000111 11000000 00001010 00000000 00000000 00000000
 mov eax, 10          ; 32비트 정수 저장 (int)
 → 10111000 00001010 00000000 00000000 00000000
 mov ax, 10           ; 16비트 정수 저장 (short)
 → 01100110 10111000 00001010 00000000
 mov al, 10           ; 8비트 정수 저장 (char)
 → 10110000 00001010
 // x86-64
```

같은 mov 명령이라도 각 명령어 안에 데이터가 담길 레지스터가 달리 정의되어 있다.

### 운영체제 (OS, Operating System)

### ELF (Executable and Linkable Format)

ELF는 많은 유닉스 계열 운영체제의 실행 파일, 오브젝트 파일, 공유 라이브러리, 코어 덤프 등에 사용되는 바이너리 파일의 규격이다.

\* 참고: 1970년대 UNIX → BSD/AT&T → macOS, Linux, Android ...

ELF의 보편적인 구조는 다음과 같다.

\* ELF의 종류(커널, 사용자 프로그램, 라이브러리, 오브젝트 등)에 따라 일부 섹션이 생략되거나 추가되어 있을 수 있다.

```
 +-----------------------------+
 | ELF Header                  | ← 현재 파일에 대한 정보 (파일의 종류, ELF 버전, 호환되는 OS, ...)
 +-----------------------------+
 | Program Header Table        | ← OS가 메모리에 올릴 때 참고할 정보 (ELF 파일의 어느 부분을 RAM의 어디에 올려야 하는지를 정의)
 +-----------------------------+
 | .text                       | ← 기계어 명령어
 | .rodata                     | ← 상수 데이터(ex: 문자열 리터럴, 전역 선언된 const int x = 10;)
 | .data                       | ← 초기값 있는 전역 변수
 | .bss                        | ← 초기값 없는 전역 변수
 | .symtab                     | ← 심볼(변수, 함수명) 정보
 | .got                        | ← 외부 함수/변수 주소 테이블 (Global Offset Table)
 | .rel.plt                    | ← 링크 정보
 | ...                         |
 +-----------------------------+
 | Section Header Table        | ← 각 섹션의 이름, 크기, 위치
 +-----------------------------+
```

> 예시

간단한 C코드의 실행 과정을 살펴 보자.

```C
#include <stdio.h>

int main(void) {
    int a = 10;
    int b = 10;
    return a + b;
}
```

위 코드를 컴파일하면, 다음과 같다.

```assembly
0000000000401130 <main>:
  401130:  55                      push   %rbp
  401131:  48 89 e5                mov    %rsp, %rbp
  401134:  c7 45 fc 0a 00 00 00    movl   $10, -0x4(%rbp)     # int a = 10
  40113b:  c7 45 f8 0a 00 00 00    movl   $10, -0x8(%rbp)     # int b = 10
  401142:  8b 45 fc                mov    -0x4(%rbp), %eax    # eax = a
  401145:  03 45 f8                add    -0x8(%rbp), %eax    # eax = eax + b
  401148:  5d                      pop    %rbp
  401149:  c3                      ret
```

`0x401130`, `0x401145` 는 **가상 주소(Virtual Address)**이다.
프로그램이 실행될 때, 운영체제는 ELF 파일의 각 섹션(.text, .data, .bss 등)을
ELF 헤더에 명시된 기준 주소(base address, 예: 0x400000)를 기반으로
프로세스마다 독립된 가상 메모리 공간(Virtual Address Space)에 매핑(mapping) 한다.
이후 CPU는 **MMU(Memory Management Unit)**라는 하드웨어 장치를 통해
프로그램이 사용하는 가상 주소(Virtual Address)를 실제 물리 주소(Physical Address)로 변환하여 접근한다.
이때 변환에 필요한 정보는 운영체제가 관리하는 페이지 테이블(Page Table)이라는 자료구조에 저장되어 있다.
