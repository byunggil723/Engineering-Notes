# 집합의 표현

> 문제

초기에 $n+1$개의 집합 $\{0\}, \{1\}, \{2\}, \dots , \{n\}$이 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.

집합을 표현하는 프로그램을 작성하시오.

> 입력

첫째 줄에 $n$, $m$이 주어진다. $m$은 입력으로 주어지는 연산의 개수이다.<br>
다음 $m$개의 줄에는 각각의 연산이 주어진다. 합집합은 $0$ $a$ $b$의 형태로 입력이 주어진다. 이는 $a$가 포함되어 있는 집합과, $b$가 포함되어 있는 집합을 합친다는 의미이다.<br>
두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은 $1$ $a$ $b$의 형태로 입력이 주어진다. 이는 $a$와 $b$가 같은 집합에 포함되어 있는지를 확인하는 연산이다.

> 출력

1로 시작하는 입력에 대해서 $a$와 $b$가 같은 집합에 포함되어 있으면 "YES" 또는 "yes"를, 그렇지 않다면 "NO" 또는 "no"를 한 줄에 하나씩 출력한다.

> 제한

 $1 ≤ n ≤ 1\,000\,000$ <br>
 $1 ≤ m ≤ 100\,000$ <br>
 $0 ≤ a, b ≤ n$ <br>
 $a$, $b$는 정수 <br>
 $a$와 $b$는 같을 수도 있다.

> 풀이

유니온-파인드 알고리즘을 활용하는 대표 문제.

### 정답 코드

```C++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int n = 0, m = 0;
vector<int> parent;
vector<string> answer;

int find_set(int x)
{
  if (parent[x] == x)
    return x;

  return parent[x] = find_set(parent[x]);
}

void union_set(int a, int b)
{
  if (a == b)
    return;

  int representative_of_a = find_set(a);
  int representative_of_b = find_set(b);

  if (representative_of_a > representative_of_b)
    parent[representative_of_a] = representative_of_b;
  else
    parent[representative_of_b] = representative_of_a;
}

int main()
{
  cin.tie(NULL);
  ios::sync_with_stdio(false);

  cin >> n >> m;

  for (int i = 0; i <= n; i++)
    parent.push_back(i);

  int order = 0, a = 0, b = 0;
  while (m > 0)
  {
    m--;

    cin >> order >> a >> b;

    if (order == 0)
      union_set(a, b);
    else
    {
      if (find_set(a) == find_set(b))
        answer.push_back("YES");
      else
        answer.push_back("NO");
    }
  }

  for (int i = 0; i < answer.size(); i++)
    cout << answer[i] << '\n';
}
```
