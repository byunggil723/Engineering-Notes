# 합이 0인 네 정수

> 문제

정수로 이루어진 크기가 같은 배열 A, B, C, D가 있다.<br>
A[a], B[b], C[c], D[d]의 합이 0인 (a, b, c, d) 쌍의 개수를 구하는 프로그램을 작성하시오.

> 입력

첫째 줄에 배열의 크기 n (1 ≤ n ≤ 4000)이 주어진다.<br>
다음 n개 줄에는 A, B, C, D에 포함되는 정수가 공백으로 구분되어져서 주어진다.<br>
배열에 들어있는 정수의 절댓값은 최대 228이다.<br>

> 출력

합이 0이 되는 쌍의 개수를 출력한다.

> 풀이

Meet in the Middle 이라는 알고리즘을 활용한다.<br>

N개의 원소를 가진 집합의 부분 집합을 모두 탐색한다 하자. <br>
만약 주어진 그대로 모든 부분 집합을 탐색한다면, 전체 $O(2^N)$이라는 시간이 걸릴 것이다.<br>
따라서, 주어진 크기 N의 집합을 절반으로 나누어 각각의 부분 집합을 구하고,<br>

A: $2^{N/2}$<br>
B: $2^{N/2}$

두 결과를 정렬 / 이분 탐색 / 해시 등을 이용해 결합한다면,<br>

결과적으로 전체 시간 복잡도는

$O(2^{N/2}log2^{N/2})$

가 될 것이다.

이 문제 역시 네 개의 배열을 두 묶음으로 나눈 뒤,<br>
각 묶음에서 가능한 모든 합의 경우를 먼저 계산하고,<br>
마지막으로 두 합의 합이 0이 되는 경우를 찾으면 된다.

### 정답 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int n = 0;
vector<int> A;
vector<int> B;
vector<int> C;
vector<int> D;
vector<int> E;
long long answer = 0;

int main()
{
  cin.tie(NULL);
  ios::sync_with_stdio(false);

  cin >> n;

  int a = 0, b = 0, c = 0, d = 0;
  for (int i = 0; i < n; i++)
  {
    cin >> a >> b >> c >> d;

    A.push_back(a);
    B.push_back(b);
    C.push_back(c);
    D.push_back(d);
  }

  for (int i = 0; i < n; i++)
  {
    for (int j = 0; j < n; j++)
    {
      E.push_back(C[i] + D[j]);
    }
  }

  sort(E.begin(), E.end(), [](int a, int b)
       { return a < b; });

  for (int i = 0; i < n; i++)
  {
    for (int j = 0; j < n; j++)
    {
      int target = A[i] + B[j];

      auto range = equal_range(E.begin(), E.end(), -target);

      answer = answer + (range.second - range.first);
    }
  }

  cout << answer;
}
```
