# 냅색문제

> 문제

세준이는 N개의 물건을 가지고 있고, 최대 C만큼의 무게를 넣을 수 있는 가방을 하나 가지고 있다.<br>
N개의 물건을 가방에 넣는 방법의 수를 구하는 프로그램을 작성하시오.

> 입력

첫째 줄에 N과 C가 주어진다. N은 $30$보다 작거나 같은 자연수, C는 $10^9$보다 작거나 같은 음이 아닌 정수이다.<br>
둘째 줄에 물건의 무게가 주어진다. 무게도 $10^9$보다 작거나 같은 자연수이다.

> 출력

첫째 줄에 가방에 넣는 방법의 수를 출력한다.

> 풀이

이 문제는 크게 Meet in the Middle 알고리즘을 활용하여 해결한다.

전체 물건의 개수는 최대 30개인데, 이를 모두 하나의 집합으로 두고 부분 집합을 전부 탐색하면 경우의 수가<br>
$2^{30}$가 되어 제한 시간 내에 전수 탐색하는 것은 사실상 불가능하다.

따라서 전체 물건을 절반으로 나누어 두 집합 A, B로 분할한 뒤, 각 집합에 대해 가능한 모든 부분 집합의 물건 무게 합을 각각 계산한다.

A의 부분 집합 전체를 power set of A,<br>
B의 부분 집합 전체를 power set of B<br>
라고 하자.

알고리즘의 핵심 흐름은 다음과 같다.<br>

1. 집합 A, B 각각에 대해 모든 부분 집합의 무게 합을 구한다.<br>
2. power set of B를 오름차순으로 정렬한다.<br>
3. power set of A의 각 원소에 대해, 제한된 무게를 초과하지 않도록 power set of B에서 선택 가능한 경우의 수를 이분 탐색으로 계산한다.

각 과정의 시간 복잡도를 빅오 표기법 기준으로 정리하면 다음과 같다.

- A, B의 멱집합을 구하는데 걸리는 시간: $2^{15}(= 32,768) + 2^{15}(= 32,768) = 65,536$<br>
- B를 오름차순으로 정렬하는데 걸리는 시간: $2^{15}log2^{15} = 147,963$<br>
- A의 멱집합의 각 원소에 대해 조건에 부합하는 원소를 탐색하는데 걸리는 시간: $2^{15}log2^{15} = 147,963$<br>

따라서, 무작정 모든 경우의 수를 고려하는 방식$(2^{30} = 1,073,741,824)$ 보다 훨씬 적은 연산량($65,536 + 147,963 + 147,963 = 361,462$)으로 효율적인 탐색이 가능함을 알 수 있다.

이와 같은 알고리즘을 구현하기 위해 멱집합을 생성 방법을 알아 보자.<br>
대표적으로 비트 마스크 방식과 DFS 방식이 있다.

#### 비트 마스크

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
  vector<int> a = {10, 20, 30}; // 원소들
  int n = (int)a.size();

  for (int mask = 0; mask < (1 << n); mask++) {
    // mask는 0(= 0000)부터 7(= 0111)까지 순차적으로 값이 증가하고, 이는 곧 가능한 모든 부분 집합을 표현한다.
    vector<int> subset;
    for (int i = 0; i < n; i++) {
      if (mask & (1 << i)) subset.push_back(a[i]);
      // i번째 원소를 부분 집합에 포함하는지 여부를 검사하는 코드이다.
      // 예를 들어 mask = 5(= 0101)인 경우,
      // mask & (1 << i)는 i = 0, 2일 때 1이 되므로
      // 해당 인덱스의 원소 10, 30을 subset 벡터에 추가하게 된다.
    }

    // subset = 하나의 부분집합
    cout << "{ ";
    for (int x : subset) cout << x << ' ';
    cout << "}\n";
  }
}
```

#### DFS

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<int> a;
vector<int> subset;
int n;

void dfs(int idx) {
  if (idx == n) {
      // subset = 하나의 부분집합
      cout << "{ ";
      for (int x : subset) cout << x << ' ';
      cout << "}\n";
      return;
  }

  // 1) a[idx]를 포함하지 않음
  dfs(idx + 1);

  // 2) a[idx]를 포함함
  subset.push_back(a[idx]);
  dfs(idx + 1);
  subset.pop_back();
}

int main() {
  a = {10, 20, 30}; // 원소들
  n = a.size();
  dfs(0);
}
```

두 방법의 시간 복잡도는 $O(n⋅2^n)​$으로 동일하다.

### 정답 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int N = 0, C = 0, weight = 0;
vector<int> A;
vector<long long> power_set_sum_of_A;
vector<int> B;
vector<long long> power_set_sum_of_B;
long long subset_sum = 0;

void DFS(int index, vector<int> &S)
{
  if (index == S.size())
  {
    if (&S == &A)
    {
      power_set_sum_of_A.push_back(subset_sum);
    }
    if (&S == &B)
    {
      power_set_sum_of_B.push_back(subset_sum);
    }

    return;
  }

  DFS(index + 1, S);

  subset_sum = subset_sum + S[index];
  DFS(index + 1, S);
  subset_sum = subset_sum - S[index];

  return;
}

int main()
{
  cin.tie(NULL);
  ios::sync_with_stdio(false);

  cin >> N >> C;

  int half_line = N / 2;

  for (int i = 0; i < half_line; i++)
  {
    cin >> weight;

    A.push_back(weight);
  }
  for (int i = half_line; i < N; i++)
  {
    cin >> weight;

    B.push_back(weight);
  }

  DFS(0, A);
  DFS(0, B);

  sort(power_set_sum_of_B.begin(), power_set_sum_of_B.end(), [](long long a, long long b)
       { return a < b; });

  int answer = 0;
  for (int i = 0; i < power_set_sum_of_A.size(); i++)
  {
    long long target = C - power_set_sum_of_A[i];

    auto it = upper_bound(power_set_sum_of_B.begin(), power_set_sum_of_B.end(), target);

    answer = answer + (it - power_set_sum_of_B.begin());
  }

  cout << answer;
}
```
