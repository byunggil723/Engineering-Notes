# 최소 스패닝 트리

> 문제

그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.

최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.

> 입력

첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다.<br>
다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다.<br>
이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다.<br>
C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.

그래프의 정점은 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 정점 사이에 경로가 있다.<br>
최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.

> 출력

첫째 줄에 최소 스패닝 트리의 가중치를 출력한다.

> 풀이

Kruskal 혹은 Prim 알고리즘을 통해 MST를 찾는다.

### 정답 코드

#### Kruskal

```C++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <tuple>

using namespace std;

int V = 0, E = 0;
vector<tuple<int, int, int>> edges;
vector<int> parent;
long long cost = 0;

int find_set(int x)
{
  if (parent[x] == x)
    return x;

  return parent[x] = find_set(parent[x]);
}

bool union_set(int a, int b)
{
  if (a == b)
    return false;

  int representative_of_a = find_set(a);
  int representative_of_b = find_set(b);

  if (representative_of_a == representative_of_b)
    return false;

  if (representative_of_a > representative_of_b)
    parent[representative_of_a] = representative_of_b;
  else
    parent[representative_of_b] = representative_of_a;

  return true;
}

void kruskal()
{
  for (int i = 0; i < edges.size(); i++)
  {
    auto [node1, node2, edge_cost] = edges[i];

    if (union_set(node1, node2))
      cost = cost + edge_cost;
  }
}

int main()
{
  cin.tie(nullptr);
  ios::sync_with_stdio(false);

  cin >> V >> E;

  for (int i = 0; i <= V; i++)
    parent.push_back(i);

  int u = 0, v = 0, w = 0;
  for (int i = 0; i < E; i++)
  {
    cin >> u >> v >> w;

    edges.push_back({u, v, w});
  }

  sort(edges.begin(), edges.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b)
       { return get<2>(a) < get<2>(b); });

  kruskal();

  cout << cost;
}
```

#### Prim

```C++
#include <iostream>
#include <vector>
#include <queue>
#include <functional>
#include <utility>

using namespace std;

int V = 0, E = 0;
vector<vector<pair<int, int>>> graph;
vector<bool> is_visited;
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
long long cost = 0;

void prim(int start_node)
{
  pq.push({0, start_node});

  while (!pq.empty())
  {
    int current_node = pq.top().second;
    int edge_cost = pq.top().first;

    pq.pop();

    if (is_visited[current_node])
      continue;

    is_visited[current_node] = true;
    cost = cost + edge_cost;

    for (int i = 0; i < graph[current_node].size(); i++)
    {
      int next_node = graph[current_node][i].first;
      int next_edge_cost = graph[current_node][i].second;

      if (!is_visited[next_node])
        pq.push({next_edge_cost, next_node});
    }
  }
}

int main()
{
  cin.tie(NULL);
  ios::sync_with_stdio(false);

  cin >> V >> E;

  graph.assign(V + 1, vector<pair<int, int>>());
  is_visited.assign(V + 1, false);

  int u = 0, v = 0, w = 0;
  for (int i = 0; i < E; i++)
  {
    cin >> u >> v >> w;

    graph[u].push_back({v, w});
    graph[v].push_back({u, w});
  }

  prim(1);

  cout << cost;
}
```
