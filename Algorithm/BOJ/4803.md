# 트리

> 문제

그래프는 정점과 간선으로 이루어져 있다. 두 정점 사이에 경로가 있다면, 두 정점은 연결되어 있다고 한다. 연결 요소는 모든 정점이 서로 연결되어 있는 정점의 부분집합이다. 그래프는 하나 또는 그 이상의 연결 요소로 이루어져 있다.

트리는 사이클이 없는 연결 요소이다. 트리에는 여러 성질이 있다. 예를 들어, 트리는 정점이 n개, 간선이 n-1개 있다. 또, 임의의 두 정점에 대해서 경로가 유일하다.

그래프가 주어졌을 때, 트리의 개수를 세는 프로그램을 작성하시오.

> 입력

입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n ≤ 500과 m ≤ n(n-1)/2을 만족하는 정점의 개수 n과 간선의 개수 m이 주어진다.
<br>다음 m개의 줄에는 간선을 나타내는 두 개의 정수가 주어진다. 같은 간선은 여러 번 주어지지 않는다. 정점은 1번부터 n번까지 번호가 매겨져 있다. 입력의 마지막 줄에는 0이 두 개 주어진다.

> 출력

입력으로 주어진 그래프에 트리가 없다면 "No trees."를, 한 개라면 "There is one tree."를, T개(T > 1)라면 "A forest of T trees."를 테스트 케이스 번호와 함께 출력한다.

> 풀이

DFS로 각 연결 요소를 탐색하며 사이클 존재 여부를 확인하는 문제.<br>
무방향 그래프에서 DFS 중 어떤 정점의 인접 정점이 이미 방문된 상태인데, 그 정점이 현재 정점의 부모가 아니라면 해당 연결 요소에는 사이클이 존재하여 트리가 아니다.

처음에는 BFS + 가중치로 사이클 여부를 판별하려 했으나, 무방향 처리 구현이 까다롭고 가중치에 따른 사이클 판정 또한 애매해졌다.
따라서 BFS로 접근하다가 막히면 DFS로 사고를 전환해 보자.

### 정답 코드

```C++
#include <iostream>
#include <vector>

using namespace std;

int n = 1, m = 1;
vector<vector<int>> graph;
bool has_cycle = false;
vector<bool> is_visited;
vector<int> asnwer;

void dfs(int current_node, int root_node)
{
  is_visited[current_node] = true;

  for (int i = 0; i < graph[current_node].size(); i++)
  {
    int next_node = graph[current_node][i];

    if (!is_visited[next_node])
    {
      dfs(next_node, current_node);
    }
    else
    {
      if (next_node != root_node)
      {
        has_cycle = true;
      }
    }
  }
}

int main()
{
  cin.tie(NULL);
  ios::sync_with_stdio(false);

  while (true)
  {
    cin >> n >> m;

    if (n == 0 && m == 0)
      break;

    graph.assign(n + 1, vector<int>());
    is_visited.assign(n + 1, false);

    int u = 0, v = 0;
    for (int i = 0; i < m; i++)
    {
      cin >> u >> v;

      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
      if (!is_visited[i])
      {
        dfs(i, 0);

        if (!has_cycle)
          cnt++;
      }

      has_cycle = false;
    }

    asnwer.push_back(cnt);
  }

  for (int i = 0; i < asnwer.size(); i++)
  {
    if (asnwer[i] == 0)
    {
      cout << "Case " << i + 1 << ": No trees." << '\n';
    }
    else if (asnwer[i] == 1)
    {
      cout << "Case " << i + 1 << ": There is one tree." << '\n';
    }
    else
    {
      cout << "Case " << i + 1 << ": A forest of " << asnwer[i] << " trees." << '\n';
    }
  }
}
```
