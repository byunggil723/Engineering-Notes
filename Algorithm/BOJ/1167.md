# 트리의 지름

> 문제

트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.

> 입력

트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.

먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다.<br>
예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다.<br>
각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.

> 출력

첫째 줄에 트리의 지름을 출력한다.

> 풀이

트리에서 임의의 정점으로부터 가장 거리가 먼 정점은 반드시 지름의 끝점 중 하나가 된다는 것을 이용한다.

### 정답 코드

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int V = 0;
vector<vector<pair<int, int>>> graph;

pair<int, int> BFS(int start_node)
{
  vector<int> dist(V + 1, 0);
  vector<bool> is_visited(V + 1, false);
  queue<int> q;

  is_visited[start_node] = true;
  q.push(start_node);

  while (!q.empty())
  {
    int current_node = q.front();

    q.pop();

    for (int i = 0; i < graph[current_node].size(); i++)
    {
      int next_node = graph[current_node][i].first;
      int cost = graph[current_node][i].second;

      if (!is_visited[next_node])
      {
        is_visited[next_node] = true;
        dist[next_node] = dist[current_node] + cost;
        q.push(next_node);
      }
    }
  }

  int max_dist = 0;
  int result_node = 0;
  for (int i = 1; i <= V; i++)
  {
    if (max_dist < dist[i])
    {
      max_dist = dist[i];
      result_node = i;
    }
  }

  return {result_node, max_dist};
}

int main()
{
  cin.tie(NULL);
  ios::sync_with_stdio(false);

  cin >> V;

  graph.assign(V + 1, vector<pair<int, int>>());

  for (int i = 0; i < V; i++)
  {
    int parent = 0, child = 0, cost = 0;

    cin >> parent;

    while (true)
    {
      cin >> child;

      if (child == -1)
        break;

      cin >> cost;

      graph[parent].push_back({child, cost});
    }
  }

  pair<int, int> result = BFS(1);

  int first_node = result.first;

  pair<int, int> result2 = BFS(first_node);

  int diameter = result2.second;

  cout << diameter;
}
```
